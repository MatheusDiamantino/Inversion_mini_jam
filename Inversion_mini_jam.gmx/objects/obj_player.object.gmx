<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprite3</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Initialize Variables
grav = 0.1;
hsp = 0;
vsp = 0;
jumpspeed = 3;
movespeed = 3;
mouse_click = false;
mouseX = 0;
mouseY = 0;

//Init camera

instance_create(x, y, ctrl_view);

enum state
{
    DOWN,
    UP,
    RIGHT,
    LEFT,
    NO_INPUT
}

state_player = state.DOWN;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Get the player's input
key_right = keyboard_check(ord('D'));
key_left = -keyboard_check(ord('A'));
key_up = -keyboard_check(ord('W'));
key_down = keyboard_check(ord('S'));
key_jump = keyboard_check_pressed(vk_space);
image_speed = 0.02;
if(!mouse_click) 
{
    switch(state_player)
    {
        case state.DOWN:
            //React to inputs
            move = key_left + key_right;
            if(move != 0) image_xscale = move;
            hsp = move * movespeed;
            if (vsp &lt; 10) vsp += grav;
            
            if (place_meeting(x,y+1,obj_wall_parent))
            {
                vsp = key_jump * -jumpspeed
            }
            //Horizontal Collision
            if (place_meeting(x+hsp,y,obj_wall_parent))
            {
                while(!place_meeting(x+sign(hsp),y,obj_wall_parent))
                {
                    x += sign(hsp);
                }
                hsp = 0;
            }
            x += hsp;
            //Vertical Collision
            if (place_meeting(x,y+vsp,obj_wall_parent))
            {
                while(!place_meeting(x,y+sign(vsp),obj_wall_parent))
                {
                    y += sign(vsp);
                }
                vsp = 0;
            }
            y += vsp;
            break;
            
        case state.UP:
            //React to inputs
            move = -(key_left + key_right);
            if(move != 0) image_xscale = -move;
            hsp = move * movespeed;
            if (vsp &lt; 10) vsp += grav;
            
            if (place_meeting(x,y-1,obj_wall_parent))
            {
                vsp = key_jump * -jumpspeed
            }
            
            //Horizontal Collision
            if (place_meeting(x+hsp,y,obj_wall_parent))
            {
                while(!place_meeting(x+sign(hsp),y,obj_wall_parent))
                {
                    x += sign(hsp);
                }
                hsp = 0;
            }
            x += hsp;
            //Vertical Collision
            if (place_meeting(x,y-vsp,obj_wall_parent))
            {
                while(!place_meeting(x,y-sign(vsp),obj_wall_parent))
                {
                    y -= sign(vsp);
                }
                vsp = 0;
            }
            y -= vsp;
            break;
            
        case state.RIGHT:
            //React to inputs
            move = -(key_left + key_right);
            if(move != 0) image_xscale = -move;
            vsp = move * movespeed;
            if (hsp &lt; 10) hsp += grav;
            
            if (place_meeting(x+1,y,obj_wall_parent))
            {
                hsp = key_jump * -jumpspeed
            }
            //Horizontal Collision
            if (place_meeting(x+hsp,y,obj_wall_parent))
            {
                while(!place_meeting(x+sign(hsp),y,obj_wall_parent))
                {
                    x += sign(hsp);
                }
                hsp = 0;
            }
            x += hsp;
            //Vertical Collision
            if (place_meeting(x,y+vsp,obj_wall_parent))
            {
                while(!place_meeting(x,y+sign(vsp),obj_wall_parent))
                {
                    y += sign(vsp);
                }
                vsp = 0;
            }
            y += vsp;
            break;
            
        case state.LEFT:
            //React to inputs
            move = (key_left + key_right);
            if(move != 0) image_xscale = move;
            vsp = move * movespeed;
            if (hsp &lt; 10) hsp += grav;
            
            if (place_meeting(x-1,y,obj_wall_parent))
            {
                hsp = key_jump * -jumpspeed
            }
            //Horizontal Collision
            if (place_meeting(x-hsp,y,obj_wall_parent))
            {
                while(!place_meeting(x-sign(hsp),y,obj_wall_parent))
                {
                    x -= sign(hsp);
                }
                hsp = 0;
            }
            x -= hsp;
            //Vertical Collision
            if (place_meeting(x,y+vsp,obj_wall_parent))
            {
                while(!place_meeting(x,y+sign(vsp),obj_wall_parent))
                {
                    y += sign(vsp);
                }
                vsp = 0;
            }
            y += vsp;
            break;
            
            
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Follow Mouse

u = 1;
d = 1;
l = 1;
r = 1;

if(!mouse_click){
    mouseX=mouse_x;
    mouseY=mouse_y;
}
if(mouse_check_button_pressed(mb_left))
{
    tempx = sign(x - mouseX);
    tempy = sign(y - mouseY);
    if(state_player == state.UP) u = 0;
    else if(state_player == state.DOWN) d = 0;
    else if(state_player == state.LEFT) l = 0;
    else if(state_player == state.RIGHT) r = 0;
    
    if (place_meeting(mouseX, mouseY, obj_grav_box_up) &amp;&amp; state_player != state.UP)
    {
        state_player = state.UP;
        if(tempy &gt;= 0) mouse_click = true;
    } else
    if (place_meeting(mouseX, mouseY, obj_grav_box_down) &amp;&amp; state_player != state.DOWN)
    {
        state_player = state.DOWN;
        if(tempy &lt; 0) mouse_click = true;
    } else   
    if (place_meeting(mouseX, mouseY, obj_grav_box_left) &amp;&amp; state_player != state.LEFT)
    {
        state_player = state.LEFT;
       if(tempx &gt;= 0) mouse_click = true;
    } else   
    if (place_meeting(mouseX, mouseY, obj_grav_box_right) &amp;&amp; state_player != state.RIGHT)
    {
        state_player = state.RIGHT;
        if(tempx &lt; 0) mouse_click = true;
    }
}

if(mouse_click){
    dist = point_distance(mouseX, mouseY, x, y);
    dir = point_direction(x, y, mouseX, mouseY);
    
    if(dist &lt; 10 || d*place_meeting(x, y + 1, obj_wall_parent)
        || u*place_meeting(x, y - 1, obj_wall_parent)
        || r*place_meeting(x + 1, y, obj_wall_parent)
        || l*place_meeting(x - 1, y, obj_wall_parent))
    {
        mouse_click = false;
    } else
    {
        x += lengthdir_x(2, dir);
        y += lengthdir_y(2, dir);
    }
    
    
}

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Rotate View

if(state_player == state.UP) 
{
    offset = 180 - view_angle[0];
    if(offset &lt;= -3 || offset &gt;= 3) view_angle[0] += 3 * sign(offset);
} else
if(state_player == state.DOWN)
{
    offset = 0 - view_angle[0];
    if(offset &lt;= -3 || offset &gt;= 3) view_angle[0] += 3 * sign(offset);
}else
if(state_player == state.RIGHT)
{
    offset = 270 - view_angle[0];
    if(offset &lt;= -3 || offset &gt;= 3) view_angle[0] += 3 * sign(offset);
}else
if(state_player == state.LEFT)
{
    offset = 90 - view_angle[0];
    if(offset &lt;= -3 || offset &gt;= 3) view_angle[0] += 3 * sign(offset);
}

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Rotate Player

if(state_player == state.UP) 
{
    image_angle = 180;
} else
if(state_player == state.DOWN)
{
    image_angle = 0;
}else
if(state_player == state.RIGHT)
{
  image_angle = 90;
}else
if(state_player == state.LEFT)
{
    image_angle = 270;
}
draw_self()

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>1</PhysicsObjectShape>
  <PhysicsObjectDensity>0</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
